import{_ as s,o as e,c as a,R as i}from"./chunks/framework.SHoGXsR8.js";const _=JSON.parse('{"title":"circular dependency如何解决","description":"","frontmatter":{},"headers":[],"relativePath":"articles/BackEnd/NestJs/circularDep/index.md","filePath":"articles/BackEnd/NestJs/circularDep/index.md","lastUpdated":null}'),t={name:"articles/BackEnd/NestJs/circularDep/index.md"},n=i(`<h1 id="circular-dependency如何解决" tabindex="-1">circular dependency如何解决 <a class="header-anchor" href="#circular-dependency如何解决" aria-label="Permalink to &quot;circular dependency如何解决&quot;">​</a></h1><p><strong>为什么会出现circulr dependency?</strong> 有两个模块A和B，A依赖B，B依赖A，这样就形成了循环依赖。 因为Nest解析是从上到下的，所以当解析到A时，A依赖B，但是B还没有解析，所以会报错。</p><p>解决办法:</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    imports:[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forwardRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BModule)],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>nest 会单独创建两个 Module，之后再把 Module 的引用转发过去，也就是 forwardRef 的含义。 provider 之间也会形成循环依赖，解决方案同上</p>`,5),r=[n];function l(c,p,d,h,o,k){return e(),a("div",null,r)}const u=s(t,[["render",l]]);export{_ as __pageData,u as default};
